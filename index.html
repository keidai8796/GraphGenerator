<!DOCTYPE html>
<html>
<head>
	<title>GraphGenerator</title>
	<style>
		#graph{
			display:flex;
		}
		#canvas{
			border:1px solid black;
		}
		#settings{
			width:600px;
			margin-left:30px;
		}
		#graph-settings{
			margin-bottom:20px;
			border-bottom:1px solid black;
		}
	</style>
</head>
<body>
	<h1>離散グラフを生成するアプリです</h1>
	<div id="graph">
		<canvas id="canvas" width="600" height="600"></canvas>
		<div id="settings">
			<div id="graph-settings">
				クリックモード：
				<select onchange="changeClickMode(this.value)">
					<option value="moveVertex">頂点を移動</option>
					<option value="addVertex">頂点を追加</option>
					<option value="addEdge">辺を追加</option>
				</select>
				<br><br>
			</div>
			<div id="object-settings"></div>
		</div>
	</div>
	
	<script>
	const canvas=document.getElementById('canvas');
	const ctx=canvas.getContext('2d');
	
	//頂点クラス
	class Vertex{
		//コンストラクタ
		constructor(x,y,radius){
			this.x=x;
			this.y=y;
			this.radius=radius;
			this.fillColor='black';
			this.borderColor='black';
			this.borderWidth=1;
			this.fill=false;
			this.edges=[];
		}
		
		//頂点を描画する関数
		draw(){
			if(this.fill){
				ctx.beginPath();
				ctx.arc(this.x,this.y,Math.abs(this.radius),0,2*Math.PI);
				ctx.fillStyle=this.fillColor;
				ctx.fill();
			}
			
			ctx.beginPath();
			ctx.arc(this.x,this.y,Math.abs(this.radius),0,2*Math.PI);
			ctx.strokeStyle=this.borderColor;
			ctx.lineWidth=this.borderWidth;
			ctx.stroke();
		}
		
		//指定された座標が頂点と重なっているかを判定			
		isPointOverlapping(x,y){
			let dx=this.x-x;
			let dy=this.y-y;
			return dx**2+dy**2<=(this.radius+this.borderWidth)**2;
		}
	}
	
	//辺クラス
	class Edge{
		//コンストラクタ
		constructor(vertex1,vertex2,radius){
			this.vertex1=vertex1;
			this.vertex2=vertex2;
			this.color='black';
			this.radius=radius;
			this.arc=false;
			this.width=1;
			this.largeArc=false;
			vertex1.edges.push(this);
			vertex2.edges.push(this);
		}
		
		//直線の始点と終点を計算する関数
		calcLine(){
			let theta=Math.atan2(this.vertex2.y-this.vertex1.y,this.vertex2.x-this.vertex1.x);
			let x1=this.vertex1.x+Math.cos(theta)*this.vertex1.radius;
			let y1=this.vertex1.y+Math.sin(theta)*this.vertex1.radius;
			let x2=this.vertex2.x-Math.cos(theta)*this.vertex2.radius;
			let y2=this.vertex2.y-Math.sin(theta)*this.vertex2.radius;
			return {x1:x1,y1:y1,x2:x2,y2:y2};
		}
		
		//弧の中心と角度を計算する関数
		calcArc(){
			//2頂点の座標を通る半径rの弧の中心(cx1,cy1),(cx2,cy2)を求める
			let cx1,cx2,cy1,cy2;
			let r=Math.abs(this.radius);
			
			r=Math.max(r,Math.sqrt((this.vertex1.x-this.vertex2.x)**2+(this.vertex1.y-this.vertex2.y)**2)/2+10);
			
			if(this.vertex1.y==this.vertex2.y){
				cx1=(this.vertex1.x+this.vertex2.x)/2;
				cx2=cx1;
				cy1=this.vertex1.y+Math.sqrt(r**2-((this.vertex2.x-this.vertex1.x)/2)**2);
				cy2=this.vertex1.y-Math.sqrt(r**2-((this.vertex2.x-this.vertex1.x)/2)**2);
			}else{
				//連立方程式(x-x1)^2+(y-y1)^2=r^2,(x-x2)^2+(y-y2)^2=r^2を解く
				//ax^2+bx+c=0の解の公式を使っている
				let tmp=(this.vertex2.x**2-this.vertex1.x**2+this.vertex2.y**2-this.vertex1.y**2)/(2*(this.vertex2.y-this.vertex1.y))-this.vertex1.y;
				let a=1+((this.vertex2.x-this.vertex1.x)/(this.vertex2.y-this.vertex1.y))**2;
				let b=-2*(this.vertex1.x+(this.vertex2.x-this.vertex1.x)/(this.vertex2.y-this.vertex1.y)*tmp);
				let c=this.vertex1.x**2+tmp**2-r**2;
				cx1=(-b+Math.sqrt(b**2-4*a*c))/(2*a);
				cx2=(-b-Math.sqrt(b**2-4*a*c))/(2*a);
				cy1=-(this.vertex2.x-this.vertex1.x)/(this.vertex2.y-this.vertex1.y)*cx1+tmp+this.vertex1.y;
				cy2=-(this.vertex2.x-this.vertex1.x)/(this.vertex2.y-this.vertex1.y)*cx2+tmp+this.vertex1.y;
			}
			
			//外積が正の点を(cx1,cy1)とする
			if((this.vertex2.x-this.vertex1.x)*(cy1-this.vertex1.y)-(this.vertex2.y-this.vertex1.y)*(cx1-this.vertex1.x)<0){
				cx1=cx2+(cx2=cx1,0);
				cy1=cy2+(cy2=cy1,0);
			}
			
			//実際に描画する弧の中心と偏角を決定
			let cx,cy;
			let theta1,theta2;
			
			//半径が負の時，逆側に弧を張るようにする
			if(this.radius>0){
				if(!this.largeArc){
					//小さい弧
					theta1=Math.atan2(this.vertex1.y-cy1,this.vertex1.x-cx1)+Math.acos(1-this.vertex1.radius**2/(2*r**2));
					theta2=Math.atan2(this.vertex2.y-cy1,this.vertex2.x-cx1)-Math.acos(1-this.vertex2.radius**2/(2*r**2));
					cx=cx1;
					cy=cy1;
				}else{
					//大きい弧
					theta1=Math.atan2(this.vertex1.y-cy2,this.vertex1.x-cx2)+Math.acos(1-this.vertex1.radius**2/(2*r**2));
					theta2=Math.atan2(this.vertex2.y-cy2,this.vertex2.x-cx2)-Math.acos(1-this.vertex2.radius**2/(2*r**2));
					cx=cx2;
					cy=cy2;
				}
			}else{
				if(!this.largeArc){
					//小さい弧
					theta1=Math.atan2(this.vertex2.y-cy2,this.vertex2.x-cx2)+Math.acos(1-this.vertex2.radius**2/(2*r**2));
					theta2=Math.atan2(this.vertex1.y-cy2,this.vertex1.x-cx2)-Math.acos(1-this.vertex1.radius**2/(2*r**2));
					cx=cx2;
					cy=cy2;
				}else{
					//大きい弧
					theta1=Math.atan2(this.vertex2.y-cy1,this.vertex2.x-cx1)+Math.acos(1-this.vertex2.radius**2/(2*r**2));
					theta2=Math.atan2(this.vertex1.y-cy1,this.vertex1.x-cx1)-Math.acos(1-this.vertex1.radius**2/(2*r**2));
					cx=cx1;
					cy=cy1;
				}
			}
			
			return {cx:cx,cy:cy,theta1:theta1,theta2:theta2,r:r};
		}
		
		//辺を描画する関数
		draw(){
			if((this.vertex1.x-this.vertex2.x)**2+(this.vertex1.y-this.vertex2.y)**2<=(this.vertex1.radius+this.vertex2.radius)**2){
				return;
			}
			
			if(!this.arc){
				//直線の描画
				let line=this.calcLine();
				ctx.beginPath();
				ctx.moveTo(line.x1,line.y1);
				ctx.lineTo(line.x2,line.y2);
				ctx.strokeStyle=this.color;
				ctx.lineWidth=this.width;
				ctx.stroke();
			}
			
			if(this.arc){
				//弧の描画
				let arc=this.calcArc();
				ctx.beginPath();
				ctx.arc(arc.cx,arc.cy,arc.r,arc.theta1,arc.theta2);
				ctx.strokeStyle=this.color;
				ctx.lineWidth=this.width;
				ctx.stroke();
			}
		}
		
		//指定された座標が辺と重なっているかを判定する
		isPointOverlapping(x,y){
			if((this.vertex1.x-this.vertex2.x)**2+(this.vertex1.y-this.vertex2.y)**2<=(this.vertex1.radius+this.vertex2.radius)**2){
				return;
			}
			
			let d=1e9;
			
			//それぞれ線分の端点と微分が0となる点で線との距離を計算して最小値を得る
			if(!this.arc){
				//直線との判定
				let line=this.calcLine();
				
				d=Math.min(d,Math.sqrt((line.x1-x)**2+(line.y1-y)**2));
				d=Math.min(d,Math.sqrt((line.x2-x)**2+(line.y2-y)**2));
				if((line.x2-line.x1)**2+(line.y2-line.y1)**2!=0){
					let t=-((line.x2-line.x1)*(line.x1-x)+(line.y2-line.y1)*(line.y1-y))/((line.x2-line.x1)**2+(line.y2-line.y1)**2);
					if(0<=t&&t<=1){
						d=Math.min(d,Math.sqrt((line.x1+(line.x2-line.x1)*t-x)**2+(line.y1+(line.y2-line.y1)*t-y)**2));
					}
				}
			}
			
			if(this.arc){
				//弧との判定
				let arc=this.calcArc();
				let theta=Math.atan2(y-arc.cy,x-arc.cx);
				
				d=Math.min(d,Math.sqrt((x-arc.cx-arc.r*Math.cos(arc.theta1))**2+(y-arc.cy-arc.r*Math.sin(arc.theta1))**2));
				d=Math.min(d,Math.sqrt((x-arc.cx-arc.r*Math.cos(arc.theta2))**2+(y-arc.cy-arc.r*Math.sin(arc.theta2))**2));
				if(arc.theta1<=arc.theta2){
					if(arc.theta1<=theta&&theta<=arc.theta2){
						d=Math.min(d,Math.sqrt((x-arc.cx-arc.r*Math.cos(theta))**2+(y-arc.cy-arc.r*Math.sin(theta))**2));
					}	
				}else{
					if(theta<=arc.theta2||arc.theta1<=theta){
						d=Math.min(d,Math.sqrt((x-arc.cx-arc.r*Math.cos(theta))**2+(y-arc.cy-arc.r*Math.sin(theta))**2));
					}
				}
			}
			
			return d<=10;
		}
	}
	
	let vertices=[new Vertex(100,100,5),new Vertex(200,100,5)];
	let edges=[new Edge(vertices[0],vertices[1],100)];
	
	//グラフを描画する関数
	function draw(){
		//canvasを初期化
		ctx.clearRect(0,0,canvas.clientWidth,canvas.height);
		
		//頂点を描画
		vertices.forEach((vertex)=>vertex.draw());
		
		//辺を描画
		edges.forEach((edge)=>edge.draw());
	}
	
	let clickMode="moveVertex";
	let selectedVertex=null;
	let draggedObject=null;
	let clickOffsetX,clickOffsetY;
	let focusObject;
	
	function changeClickMode(mode){
		clickMode=mode;
		switch(clickMode){
			case "moveVertex":
				selectedVertex=null;
				break;
			case "addedge":
				draggedObject=null;
				break;
			default:
				selectedVertex=null;
				draggedObject=null;
				break;
		}
	}
	
	//フォーカスするオブジェクトを設定する
	function setFocusObject(object){
		focusObject=object;
		let container=document.getElementById("object-settings");
		container.innerHTML='';
		
		//フォーカスしているオブジェクトによって表示内容を変える
		if(object instanceof Vertex){
			//座標の表示
			let coordinateDiv=document.createElement('div');
			coordinateDiv.id='coordinate'
			let coordinateLabel=document.createElement('label');
			coordinateLabel.textContent='頂点の座標　：';
			coordinateDiv.appendChild(coordinateLabel);
			
			let coordinateXLabel=document.createElement('label')
			coordinateXLabel.textContent='x=';
			coordinateDiv.appendChild(coordinateXLabel);
			
			let coordinateXText=document.createElement('input');
			coordinateXText.type='text';
			coordinateXText.id='coordinateX';
			coordinateXText.value=focusObject.x;
			coordinateXText.size=1;
			coordinateXText.onchange=function(){
				let x=parseFloat(coordinateXText.value);
				if(!isNaN(x)){
					if(x<=0)x=0;
					if(x>=600)x=600;
					coordinateXText.value=x;
					focusObject.x=x;
					draw();
				}
			}
			coordinateDiv.appendChild(coordinateXText);
			
			let coordinateYLabel=document.createElement('label');
			coordinateYLabel.textContent=', y=';
			coordinateDiv.appendChild(coordinateYLabel);
			
			let coordinateYText=document.createElement('input');
			coordinateYText.type='text';
			coordinateYText.id='coordinateY';
			coordinateYText.value=focusObject.y;
			coordinateYText.size=1;
			coordinateYText.onchange=function(){
				let y=parseFloat(coordinateYText.value);
				if(!isNaN(y)){
					if(y<=0)y=0;
					if(y>=600)y=600;
					coordinateYText.value=y;
					focusObject.y=y;
					draw();
				}
			}
			coordinateDiv.appendChild(coordinateYText);
			container.appendChild(coordinateDiv);
			
			//頂点の半径の設定
			let radiusDiv=document.createElement('div');
			radiusDiv.id='radius';
			let radiusLabel=document.createElement('label');
			radiusLabel.textContent='頂点の半径　：';
			radiusDiv.appendChild(radiusLabel);
			
			let radiusValueDiv=document.createElement('div');
			radiusValueDiv.style='display:inline-block;vertical-align:top;';
			radiusValueDiv.id='radiusValue';
			let radiusText=document.createElement('input');
			radiusText.type='text';
			radiusText.id='radiusText';
			radiusText.size=14;
			radiusText.value=focusObject.radius;
			radiusText.onchange=function(){
				let r=parseFloat(radiusText.value);
				if(!isNaN(r)){
					if(r<=3)r=3;
					if(r>=50)r=50;
					radiusText.value=r;
					focusObject.radius=r;
					document.getElementById('radiusRange').value=r;
					draw();
				}
			}
			radiusValueDiv.appendChild(radiusText);
			radiusValueDiv.appendChild(document.createElement('br'));
			
			let radiusRange=document.createElement('input');
			radiusRange.type='range';
			radiusRange.id='radiusRange';
			radiusRange.min=3;
			radiusRange.max=50;
			radiusRange.value=focusObject.radius;
			radiusRange.onchange=function(){
				let r=parseFloat(radiusRange.value);
				focusObject.radius=r;
				document.getElementById('radiusText').value=r;
				draw();
			};
			radiusValueDiv.appendChild(radiusRange);
			radiusDiv.appendChild(radiusValueDiv);
			container.appendChild(radiusDiv);
			
			
			//枠線の色の設定
			let borderColorDiv=document.createElement('div');
			borderColorDiv.id='borderColor';
			let borderColorLabel=document.createElement('label');
			borderColorLabel.textContent='枠線の色　　：';
			borderColorDiv.appendChild(borderColorLabel);
			
			let borderColorPicker=document.createElement('input');
			borderColorPicker.type='color';
			borderColorPicker.id='borderColorPicker';
			borderColorPicker.value=focusObject.borderColor;
			borderColorPicker.onchange=function(){
				focusObject.borderColor=borderColorPicker.value;
				draw();
			};
			borderColorDiv.appendChild(borderColorPicker);
			container.appendChild(borderColorDiv);
			
			
			//枠線の幅の設定
			let borderWidthDiv=document.createElement('div');
			borderWidthDiv.id='borderWidth';
			let borderWidthLabel=document.createElement('label');
			borderWidthLabel.textContent='枠線の幅　　：';
			borderWidthDiv.appendChild(borderWidthLabel);
			
			let borderWidthValueDiv=document.createElement('div');
			borderWidthValueDiv.style='display:inline-block;vertical-align:top;';
			borderWidthValueDiv.id='borderWidthValue';
			let borderWidthText=document.createElement('input');
			borderWidthText.type='text';
			borderWidthText.id='borderWidthText';
			borderWidthText.size=14;
			borderWidthText.value=focusObject.borderWidth;
			borderWidthText.onchange=function(){
				let w=parseFloat(borderWidthText.value);
				if(!isNaN(w)){
					if(w<=1)w=1;
					if(w>=10)w=10;
					borderWidthText.value=w;
					focusObject.borderWidth=w;
					document.getElementById('borderWidthRange').value=w;
					draw();
				}
			}
			borderWidthValueDiv.appendChild(borderWidthText);
			borderWidthValueDiv.appendChild(document.createElement('br'));
			
			let borderWidthRange=document.createElement('input');
			borderWidthRange.type='range';
			borderWidthRange.id='borderWidthRange';
			borderWidthRange.min=1;
			borderWidthRange.max=10;
			borderWidthRange.value=focusObject.borderWidth;
			borderWidthRange.onchange=function(){
				let w=parseFloat(borderWidthRange.value);
				focusObject.borderWidth=w;
				document.getElementById('borderWidthText').value=w;
				draw();
			};
			borderWidthValueDiv.appendChild(borderWidthRange);
			borderWidthDiv.appendChild(borderWidthValueDiv);
			container.appendChild(borderWidthDiv);
			
			
			//頂点の塗りつぶし設定
			let fillDiv=document.createElement('div');
			fillDiv.id='fill';
			let fillLabel=document.createElement('label');
			fillLabel.textContent='塗りつぶし　：';
			fillDiv.appendChild(fillLabel);
			
			let fillCheckbox=document.createElement('input');
			fillCheckbox.type='checkbox';
			fillCheckbox.id='fillCheckbox';
			fillCheckbox.checked=focusObject.fill;
			fillCheckbox.onclick=function(){
				focusObject.fill=fillCheckbox.checked;
				let fillColor=document.getElementById('fillColor');
				if(focusObject.fill){
					fillColor.style.display='block';
				}else{
					fillColor.style.display='none';
				}
				draw();
			};
			fillDiv.appendChild(fillCheckbox);
			container.appendChild(fillDiv);
			
			
			//塗りつぶし色の設定
			let fillColorDiv=document.createElement('div');
			fillColorDiv.id='fillColor';
			if(!focusObject.fill){
				fillColorDiv.style.display='none';
			}
			let fillColorLabel=document.createElement('label');
			fillColorLabel.textContent='塗りつぶし色：';
			fillColorDiv.appendChild(fillColorLabel);
			
			let fillColorPicker=document.createElement('input');
			fillColorPicker.type='color';
			fillColorPicker.id='fillColorPicker';
			fillColorPicker.value=focusObject.fillColor;
			fillColorPicker.onchange=function(){
				focusObject.fillColor=fillColorPicker.value;
				draw();
			};
			fillColorDiv.appendChild(fillColorPicker);
			container.appendChild(fillColorDiv);
			
			
			//頂点の削除ボタン
			let deleteButton=document.createElement('input');
			deleteButton.type='button';
			deleteButton.id='deleteVertex';
			deleteButton.value='削除';
			deleteButton.onclick=function(){
				for(let i=0;i<focusObject.edges.length;i++){
					edges=edges.filter(function(edge){
						return edge!=focusObject.edges[i];
					});
				}
				vertices=vertices.filter(function(vertex){
					return vertex!=focusObject;
				});
				setFocusObject(null);
				draw();
			};
			container.appendChild(deleteButton);
		}
		
		if(object instanceof Edge){
			//辺の色の設定
			let edgeColorDiv=document.createElement('div');
			edgeColorDiv.id='edgeColor';
			let edgeColorLabel=document.createElement('label');
			edgeColorLabel.textContent='辺の色　　：';
			edgeColorDiv.appendChild(edgeColorLabel);
			
			let edgeColorPicker=document.createElement('input');
			edgeColorPicker.type='color';
			edgeColorPicker.id='edgeColorPicker';
			edgeColorPicker.value=focusObject.color;
			edgeColorPicker.onchange=function(){
				focusObject.color=edgeColorPicker.value;
				draw();
			};
			edgeColorDiv.appendChild(edgeColorPicker);
			container.appendChild(edgeColorDiv);
			
			
			//辺の幅の設定
			let edgeWidthDiv=document.createElement('div');
			edgeWidthDiv.id='edgeWidth';
			let edgeWidthLabel=document.createElement('label');
			edgeWidthLabel.textContent='辺の幅　　：';
			edgeWidthDiv.appendChild(edgeWidthLabel);
			
			let edgeWidthValueDiv=document.createElement('div');
			edgeWidthValueDiv.style='display:inline-block;vertical-align:top;';
			edgeWidthValueDiv.id='edgeWidthValue';
			let edgeWidthText=document.createElement('input');
			edgeWidthText.type='text';
			edgeWidthText.id='edgeWidthText';
			edgeWidthText.size=14;
			edgeWidthText.value=focusObject.width;
			edgeWidthText.onchange=function(){
				let w=parseFloat(edgeWidthText.value);
				if(!isNaN(w)){
					if(w<=1)w=1;
					if(w>=10)w=10;
					edgeWidthWidthText.value=w;
					focusObject.width=w;
					document.getElementById('edgeWidthRange').value=w;
					draw();
				}
			}
			edgeWidthValueDiv.appendChild(edgeWidthText);
			edgeWidthValueDiv.appendChild(document.createElement('br'));
			
			let edgeWidthRange=document.createElement('input');
			edgeWidthRange.type='range';
			edgeWidthRange.id='edgeWidthRange';
			edgeWidthRange.min=1;
			edgeWidthRange.max=10;
			edgeWidthRange.value=focusObject.width;
			edgeWidthRange.onchange=function(){
				let w=parseFloat(edgeWidthRange.value);
				focusObject.width=w;
				document.getElementById('edgeWidthText').value=w;
				draw();
			};
			edgeWidthValueDiv.appendChild(edgeWidthRange);
			edgeWidthDiv.appendChild(edgeWidthValueDiv);
			container.appendChild(edgeWidthDiv);
			
			
			//辺を円弧状にする設定
			let arcDiv=document.createElement('div');
			arcDiv.id='arc';
			let arcLabel=document.createElement('label');
			arcLabel.textContent='弧状に表示：';
			arcDiv.appendChild(arcLabel);
			
			let arcCheckbox=document.createElement('input');
			arcCheckbox.type='checkbox';
			arcCheckbox.id='arcCheckbox';
			arcCheckbox.checked=focusObject.arc;
			arcCheckbox.onclick=function(){
				focusObject.arc=arcCheckbox.checked;
				let radius=document.getElementById('radius');
				let largeArc=document.getElementById('largeArc');
				if(focusObject.arc){
					radius.style.display='block';
					largeArc.style.display='block';
				}else{
					radius.style.display='none';
					largeArc.style.display='none';
				}
				draw();
			};
			arcDiv.appendChild(arcCheckbox);
			container.appendChild(arcDiv);
			
			
			//弧の半径の設定
			let radiusDiv=document.createElement('div');
			radiusDiv.id='radius';
			if(!focusObject.arc){
				radiusDiv.style.display='none';
			}
			let radiusLabel=document.createElement('label');
			radiusLabel.textContent='弧の半径　：';
			radiusDiv.appendChild(radiusLabel);
			
			let radiusValueDiv=document.createElement('div');
			radiusValueDiv.style='display:inline-block; vertical-align:top;';
			radiusValueDiv.id='radiusValue';
			let radiusText=document.createElement('input');
			radiusText.type='text';
			radiusText.id='radiusText';
			radiusText.size=14;
			radiusText.value=focusObject.radius;
			radiusText.onchange=function(){
				let r=parseFloat(radiusText.value);
				if(!isNaN(r)){
					if(r<=-1000)r=-1000;
					if(r>=1000)r=1000;
					radiusText.value=r;
					focusObject.radius=r;
					document.getElementById('radiusRange').value=r;
					draw();
				}
			}
			radiusValueDiv.appendChild(radiusText);
			radiusValueDiv.appendChild(document.createElement('br'));
			
			let radiusRange=document.createElement('input');
			radiusRange.type='range';
			radiusRange.id='radiusRange';
			radiusRange.min=-1000;
			radiusRange.max=1000;
			radiusRange.value=focusObject.radius;
			radiusRange.onchange=function(){
				let r=parseFloat(radiusRange.value);
				focusObject.radius=r;
				document.getElementById('radiusText').value=r;
				draw();
			};
			radiusValueDiv.appendChild(radiusRange);
			radiusDiv.appendChild(radiusValueDiv);
			container.appendChild(radiusDiv);
			
			
			//弧を大きくする設定
			let largeArcDiv=document.createElement('div');
			largeArcDiv.id='largeArc';
			if(!focusObject.arc){
				largeArcDiv.style.display='none';
			}
			let largeArcLabel=document.createElement('label');
			largeArcLabel.textContent='大きい弧　：';
			largeArcDiv.appendChild(largeArcLabel);
			
			let largeArcCheckbox=document.createElement('input');
			largeArcCheckbox.type='checkbox';
			largeArcCheckbox.id='largeArcCheckbox';
			largeArcCheckbox.checked=focusObject.largeArc;
			largeArcCheckbox.onclick=function(){
				focusObject.largeArc=largeArcCheckbox.checked;
				draw();
			};
			largeArcDiv.appendChild(largeArcCheckbox);
			container.appendChild(largeArcDiv);
			
			
			//辺の削除ボタン
			let deleteButton=document.createElement('input');
			deleteButton.type='button';
			deleteButton.id='deleteEdge';
			deleteButton.value='削除';
			deleteButton.onclick=function(){
				focusObject.vertex1.edges=focusObject.vertex1.edges.filter(function(edge){
					return edge!=focusObject;
				});
				focusObject.vertex2.edges=focusObject.vertex2.edges.filter(function(edge){
					return edge!=focusObject;
				});
				edges=edges.filter(function(edge){
					return edge!=focusObject;
				});
				setFocusObject(null);
				draw();
			};
			container.appendChild(deleteButton);
		}
	}
	
	//マウスがクリックされたときの処理
	canvas.addEventListener('mousedown',(e)=>{
		//canvas上でのマウス座標を計算
		const rect=canvas.getBoundingClientRect();
		let mouseX=e.clientX-rect.left;
		let mouseY=e.clientY-rect.top;
		
		//頂点がクリックされたかを判定
		for(let i=0;i<vertices.length;i++){
			if(vertices[i].isPointOverlapping(mouseX,mouseY)){
				switch(clickMode){
					case "moveVertex":
						draggedObject=vertices[i];
						clickOffsetX=mouseX-vertices[i].x;
						clickOffsetY=mouseY-vertices[i].y;
						break;
					case "addEdge":
						selectedVertex=vertices[i];
						break;
					default:
						break;
				}
				setFocusObject(vertices[i]);
				return;
			}
		}
		
		//辺がクリックされたかを判定
		for(let i=0;i<edges.length;i++){
			if(edges[i].isPointOverlapping(mouseX,mouseY)){
				setFocusObject(edges[i]);
				return;
			}
		}
		
		if(clickMode=='addVertex'){
			setFocusObject(new Vertex(Math.floor(mouseX),Math.floor(mouseY),5));
			vertices.push(focusObject);
			draw();
		}
		
		setFocusObject(null);
	});
	
	//マウスが移動したときの処理
	canvas.addEventListener('mousemove',(e)=>{
		const rect=canvas.getBoundingClientRect();
		let mouseX=e.clientX-rect.left;
		let mouseY=e.clientY-rect.top;
		if(draggedObject!=null){		
			draggedObject.x=mouseX-clickOffsetX;
			draggedObject.y=mouseY-clickOffsetY;
			if(focusObject==draggedObject){
				let coordinateX=document.getElementById('coordinateX');
				let coordinateY=document.getElementById('coordinateY');
				coordinateX.value=draggedObject.x;
				coordinateY.value=draggedObject.y;
			}
			draw();
		}
		if(selectedVertex!=null){
			draw();
			new Edge(selectedVertex,new Vertex(mouseX,mouseY,0)).draw();
		}
	});
	
	//マウスボタンが離されたときの処理
	canvas.addEventListener('mouseup',(e)=>{
		if(selectedVertex!=null){
			//辺を追加できるなら追加する
			const rect=canvas.getBoundingClientRect();
			let mouseX=e.clientX-rect.left;
			let mouseY=e.clientY-rect.top;
			for(let i=0;i<vertices.length;i++){
				if(vertices[i].isPointOverlapping(mouseX,mouseY)){
					setFocusObject(new Edge(selectedVertex,vertices[i],100));
					edges.push(focusObject);
					break;
				}
			}
		}
		draggedObject=null;
		selectedVertex=null;
		draw();
	});
	
	draw();
	
	</script>
</body>
</html>