<!DOCTYPE html>
<html>
<head>
	<title>GraphGenerator</title>
	<style>
		#graph{
			display:flex;
		}
		#canvas{
			border:1px solid black;
		}
		#settings{
			width:600px;
			margin-left:30px;
		}
		#graph-settings{
			margin-bottom:20px;
			border-bottom:1px solid black;
		}
	</style>
</head>
<body>
	<h1>離散グラフを生成するアプリです</h1>
	<div id="graph">
		<canvas id="canvas" width="600" height="600"></canvas>
		<div id="settings">
			<div id="graph-settings">
				クリックモード：
				<select onchange="changeClickMode(this.value)">
					<option value="moveVertex">頂点を移動</option>
					<option value="addVertex">頂点を追加</option>
					<option value="addEdge">辺を追加</option>
				</select>
				<br><br>
			</div>
			<div id="object-settings">
				<div id="vertex-settings" style="display:none;">
					<h4 id="vertexName"></h4>
					<div id="coordinate">
						頂点の座標：x=
						<input type="text" id="coordinateXText" size="1" onchange="coordinateXTextChanged(this.value)">
						, y=
						<input type="text" id="coordinateYText" size="1" onchange="coordinateYTextChanged(this.value)">
					</div>
					<div id="vertexRadius">
						頂点の半径：
						<input type="text" id="vertexRadiusText" size="14" onchange="vertexRadiusTextChanged(this.value)">
					</div>
					<div id="borderColor">
						枠線の色：
						<input type="color" id="borderColorPicker" onchange="borderColorChanged(this.value)">
					</div>
					<div id="borderWidth">
						枠線の幅：
						<input type="text" id="borderWidthText" size="14" onchange="borderWidthTextChanged(this.value)">
					</div>
					<div id="fill">
						塗りつぶし：
						<input type="checkbox" id="fillCheckbox" onchange="fillCheckboxChenged(this.checked)">
					</div>
					<div id="fillColor">
						塗りつぶし色：
						<input type="color" id="fillColorPicker" onchange="fillColorChanged(this.value)">
					</div>
					<input type="button" id="deleteVertex" value="削除" onclick="vertexDeleteButtonClicked()">
				</div>
				<div id="edge-settings" style="display:none;">
					<h4 id="edgeName"></h4>
					<div id="edgeColor">
						辺の色：
						<input type="color" id="edgeColorPicker" onchange="edgeColorChanged(this.value)">
					</div>
					<div id="edgeWidth">
						辺の幅：
						<input type="text" id="edgeWidthText" onchange="edgeWidthTextChanged(this.value)">
					</div>
					<div id="arc">
						円弧状にする：
						<input type="checkbox" id="arcCheckbox" onchange="arcCheckboxChanged(this.checked)">
					</div>
					<div id="arcRadius">
						弧の半径：
						<input type="text" id="arcRadiusText" onchange="arcRadiusTextChanged(this.value)">
					</div>
					<div id="largeArc">
						弧を大きく：
						<input type="checkbox" id="largeArcCheckbox" onchange="largeArcCheckboxChanged(this.checked)">
					</div>
					<div id="arrow">
						矢印の有無：始点
						<input type="checkbox" id="startArrowCheckbox" onchange="startArrowCheckboxChanged(this.checked)">
						終点
						<input type="checkbox" id="endArrowCheckbox" onchange="endArrowCheckboxChanged(this.checked)">
					</div>
					<div id="arrowSize">
						矢印の大きさ:
						<input type="text" id="arrowSizeText" onchange="arrowSizeTextChanged(this.value)">
					</div>
					<div id="selfLoopAngle">
						表示角度：
						<input type="text" id="selfLoopAngleText" onchange="selfLoopAngleTextChanged(this.value)">
					</div>
					<input type="button" id="deleteEdge" value="削除" onclick="edgeDeleteButtonClicked()">
				</div>
			</div>
		</div>
	</div>
	
	<script>
	const canvas=document.getElementById('canvas');
	const ctx=canvas.getContext('2d');
	
	//頂点クラス
	class Vertex{
		//コンストラクタ
		constructor(x,y,id){
			this.x=x;
			this.y=y;
			this.radius=5;
			this.id=id;
			this.fillColor='#000000';
			this.borderColor='#000000';
			this.borderWidth=1;
			this.fill=false;
			this.edges=[];
		}
		
		//頂点を描画する関数
		draw(){
			if(this.fill){
				ctx.beginPath();
				ctx.arc(this.x,this.y,Math.abs(this.radius),0,2*Math.PI);
				ctx.fillStyle=this.fillColor;
				ctx.fill();
			}
			
			ctx.beginPath();
			ctx.arc(this.x,this.y,Math.abs(this.radius),0,2*Math.PI);
			ctx.strokeStyle=this.borderColor;
			ctx.lineWidth=this.borderWidth;
			ctx.stroke();
		}
		
		//指定された座標が頂点と重なっているかを判定			
		isPointOverlapping(x,y){
			let dx=this.x-x;
			let dy=this.y-y;
			return dx**2+dy**2<=(this.radius+this.borderWidth)**2;
		}
	}
	
	//辺クラス
	class Edge{
		//コンストラクタ
		constructor(vertex1,vertex2,id){
			this.vertex1=vertex1;
			this.vertex2=vertex2;
			this.radius=100;
			this.id=id;
			this.color='#000000';
			this.arc=false;
			this.width=1;
			this.largeArc=false;
			this.arrowSize=10;
			this.startArrow=false;
			this.endArrow=false;
			this.selfLoopAngle=0;
			if(vertex1==vertex2){
				this.arc=true;
				this.radius=vertex1.radius*3;
			}
			vertex1.edges.push(this);
			vertex2.edges.push(this);
		}
		
		//直線の始点と終点を計算する関数
		calcLine(){
			let theta=Math.atan2(this.vertex2.y-this.vertex1.y,this.vertex2.x-this.vertex1.x);
			let x1=this.vertex1.x+Math.cos(theta)*(this.vertex1.radius+this.vertex1.borderWidth/2);
			let y1=this.vertex1.y+Math.sin(theta)*(this.vertex1.radius+this.vertex1.borderWidth/2);
			let x2=this.vertex2.x-Math.cos(theta)*(this.vertex2.radius+this.vertex2.borderWidth/2);
			let y2=this.vertex2.y-Math.sin(theta)*(this.vertex2.radius+this.vertex2.borderWidth/2);
			return {x1:x1,y1:y1,x2:x2,y2:y2};
		}
		
		//弧を点(x,y)を通るように更新
		updateRadius(x,y){
			let x1=this.vertex1.x,y1=this.vertex1.y;
			let x2=this.vertex2.x,y2=this.vertex2.y;
			if(this.vertex1==this.vertex2){
				this.radius=(Math.sqrt((x1-x)**2+(y1-y)**2)-this.vertex1.radius/2)/2;
				this.selfLoopAngle=Math.atan2(y-y1,x-x1)*180/Math.PI;
				return;
			}
			if((x-x2)*(y-y1)==(x-x1)*(y-y2)){
				return;
			}
			let cx,cy,r;
			if(y==y1){
				cx=(x+x1)/2;
				cy=((x2-cx)**2-(x-cx)**2+y2**2-y**2)/(2*(y2-y));
			}else if(y==y2){
				cx=(x+x2)/2;
				cy=((x1-cx)**2-(x-cx)**2+y1**2-y**2)/(2*(y1-y));
			}else{
				cx=((x**2-x2**2+y**2-y2**2)/(y-y2)-(x**2-x1**2+y**2-y1**2)/(y-y1))/((x-x2)/(y-y2)-(x-x1)/(y-y1))/2;
				cy=(-(x-x1)*cx+(x**2-x1**2+y**2-y1**2)/2)/(y-y1);
			}
			r=Math.sqrt((x-cx)**2+(y-cy)**2);
			if((x2-x1)*(y-y1)-(y2-y1)*(x-x1)>0){
				r*=-1;
			}
			this.radius=r;
			if(((x2-x1)*(cy-y1)-(y2-y1)*(cx-x1)<0)!=((x2-x1)*(y-y1)-(y2-y1)*(x-x1)<0)){
				this.largeArc=false;
			}else{
				this.largeArc=true;
			}
		}
		
		//弧の中心と角度を計算する関数
		calcArc(){
			let x1=this.vertex1.x,y1=this.vertex1.y;
			let r1=this.vertex1.radius,w1=this.vertex1.borderWidth;
			let x2=this.vertex2.x,y2=this.vertex2.y;
			let r2=this.vertex2.radius,w2=this.vertex2.borderWidth;
			let r=Math.abs(this.radius);
			//自己ループの場合
			if(this.vertex1==this.vertex2){
				let cx=x1+(r+r1/2)*Math.cos(this.selfLoopAngle/180*Math.PI);
				let cy=y1+(r+r1/2)*Math.sin(this.selfLoopAngle/180*Math.PI);
				let theta1=Math.atan2(y1-cy,x1-cx)+Math.acos(((r+r1/2)**2+r**2-r1**2)/(2*r*(r+r1/2)));
				let theta2=Math.atan2(y1-cy,x1-cx)-Math.acos(((r+r1/2)**2+r**2-r1**2)/(2*r*(r+r1/2)));
				return {cx:cx,cy:cy,theta1:theta1,theta2:theta2,r:r};
			}
			
			//2頂点の座標を通る半径rの弧の中心(cx1,cy1),(cx2,cy2)を求める
			let cx1,cx2,cy1,cy2;
			
			r=Math.max(r,Math.sqrt((x1-x2)**2+(y1-y2)**2)/2+0.01);
			
			if(y1==y2){
				cx1=(x1+x2)/2;
				cx2=cx1;
				cy1=y1+Math.sqrt(r**2-((x2-x1)/2)**2);
				cy2=y1-Math.sqrt(r**2-((x2-x1)/2)**2);
			}else{
				//連立方程式(x-x1)^2+(y-y1)^2=r^2,(x-x2)^2+(y-y2)^2=r^2を解く
				//ax^2+bx+c=0の解の公式を使っている
				let tmp=(x2**2-x1**2+y2**2-y1**2)/(2*(y2-y1))-y1;
				let a=1+((x2-x1)/(y2-y1))**2;
				let b=-2*(x1+(x2-x1)/(y2-y1)*tmp);
				let c=x1**2+tmp**2-r**2;
				cx1=(-b+Math.sqrt(b**2-4*a*c))/(2*a);
				cx2=(-b-Math.sqrt(b**2-4*a*c))/(2*a);
				cy1=-(x2-x1)/(y2-y1)*cx1+tmp+y1;
				cy2=-(x2-x1)/(y2-y1)*cx2+tmp+y1;
			}
			
			//外積が正の点を(cx1,cy1)とする
			if((x2-x1)*(cy1-y1)-(y2-y1)*(cx1-x1)<0){
				cx1=cx2+(cx2=cx1,0);
				cy1=cy2+(cy2=cy1,0);
			}
			
			//実際に描画する弧の中心と偏角を決定
			let cx,cy;
			let theta1,theta2;
			
			//半径が負の時，逆側に弧を張るようにする
			if(this.radius>0){
				if(!this.largeArc){
					//小さい弧
					theta1=Math.atan2(y1-cy1,x1-cx1)+Math.acos(1-(r1+w1/2)**2/(2*r**2));
					theta2=Math.atan2(y2-cy1,x2-cx1)-Math.acos(1-(r2+w2/2)**2/(2*r**2));
					cx=cx1;
					cy=cy1;
				}else{
					//大きい弧
					theta1=Math.atan2(y1-cy2,x1-cx2)+Math.acos(1-(r1+w1/2)**2/(2*r**2));
					theta2=Math.atan2(y2-cy2,x2-cx2)-Math.acos(1-(r2+w2/2)**2/(2*r**2));
					cx=cx2;
					cy=cy2;
				}
			}else{
				if(!this.largeArc){
					//小さい弧
					theta1=Math.atan2(y2-cy2,x2-cx2)+Math.acos(1-(r2+w2/2)**2/(2*r**2));
					theta2=Math.atan2(y1-cy2,x1-cx2)-Math.acos(1-(r1+w1/2)**2/(2*r**2));
					cx=cx2;
					cy=cy2;
				}else{
					//大きい弧
					theta1=Math.atan2(y2-cy1,x2-cx1)+Math.acos(1-(r2+w2/2)**2/(2*r**2));
					theta2=Math.atan2(y1-cy1,x1-cx1)-Math.acos(1-(r1+w1/2)**2/(2*r**2));
					cx=cx1;
					cy=cy1;
				}
			}
			
			return {cx:cx,cy:cy,theta1:theta1,theta2:theta2,r:r};
		}
		
		drawArrow(x,y,theta){
			ctx.beginPath();
			ctx.moveTo(x,y);
			ctx.lineTo(x+this.arrowSize*Math.cos(theta+Math.PI*3/4),y+this.arrowSize*Math.sin(theta+Math.PI*3/4));
			ctx.lineTo(x+this.arrowSize*Math.cos(theta+Math.PI*5/4),y+this.arrowSize*Math.sin(theta+Math.PI*5/4));
			ctx.moveTo(x,y);
			ctx.fillStyle=this.color;
			ctx.fill();
		}
		
		//辺を描画する関数
		draw(){
			if((this.vertex1.x-this.vertex2.x)**2+(this.vertex1.y-this.vertex2.y)**2<=(this.vertex1.radius+this.vertex2.radius)**2){
				if(this.vertex1!=this.vertex2){
					return;
				}
			}
			
			if(!this.arc){
				//直線の描画
				let line=this.calcLine();
				ctx.beginPath();
				ctx.moveTo(line.x1,line.y1);
				ctx.lineTo(line.x2,line.y2);
				ctx.strokeStyle=this.color;
				ctx.lineWidth=this.width;
				ctx.stroke();
				if(this.startArrow){
					this.drawArrow(line.x1,line.y1,Math.atan2(line.y1-line.y2,line.x1-line.x2));
				}
				if(this.endArrow){
					this.drawArrow(line.x2,line.y2,Math.atan2(line.y2-line.y1,line.x2-line.x1));
				}
			}
			
			if(this.arc){
				//弧の描画
				let arc=this.calcArc();
				ctx.beginPath();
				ctx.arc(arc.cx,arc.cy,arc.r,arc.theta1,arc.theta2);
				ctx.strokeStyle=this.color;
				ctx.lineWidth=this.width;
				ctx.stroke();
				if(this.startArrow){
					if(this.radius>0){
						this.drawArrow(arc.cx+arc.r*Math.cos(arc.theta1),arc.cy+arc.r*Math.sin(arc.theta1),arc.theta1-Math.PI/2);
					}else{
						this.drawArrow(arc.cx+arc.r*Math.cos(arc.theta2),arc.cy+arc.r*Math.sin(arc.theta2),arc.theta2+Math.PI/2);
					}
				}
				if(this.endArrow){
					if(this.radius<0){
						this.drawArrow(arc.cx+arc.r*Math.cos(arc.theta1),arc.cy+arc.r*Math.sin(arc.theta1),arc.theta1-Math.PI/2);
					}else{
						this.drawArrow(arc.cx+arc.r*Math.cos(arc.theta2),arc.cy+arc.r*Math.sin(arc.theta2),arc.theta2+Math.PI/2);
					}
				}
			}
		}
		
		//指定された座標が辺と重なっているかを判定する
		isPointOverlapping(x,y){
			if((this.vertex1.x-this.vertex2.x)**2+(this.vertex1.y-this.vertex2.y)**2<=(this.vertex1.radius+this.vertex2.radius)**2){
				if(this.vertex1!=this.vertex2){
					return;
				}
			}
			
			let d=1e9;
			
			//それぞれ線分の端点と微分が0となる点で線との距離を計算して最小値を得る
			if(!this.arc){
				//直線との判定
				let line=this.calcLine();
				
				d=Math.min(d,Math.sqrt((line.x1-x)**2+(line.y1-y)**2));
				d=Math.min(d,Math.sqrt((line.x2-x)**2+(line.y2-y)**2));
				if((line.x2-line.x1)**2+(line.y2-line.y1)**2!=0){
					let t=-((line.x2-line.x1)*(line.x1-x)+(line.y2-line.y1)*(line.y1-y))/((line.x2-line.x1)**2+(line.y2-line.y1)**2);
					if(0<=t&&t<=1){
						d=Math.min(d,Math.sqrt((line.x1+(line.x2-line.x1)*t-x)**2+(line.y1+(line.y2-line.y1)*t-y)**2));
					}
				}
			}
			
			if(this.arc){
				//弧との判定
				let arc=this.calcArc();
				let theta=Math.atan2(y-arc.cy,x-arc.cx);
				
				d=Math.min(d,Math.sqrt((x-arc.cx-arc.r*Math.cos(arc.theta1))**2+(y-arc.cy-arc.r*Math.sin(arc.theta1))**2));
				d=Math.min(d,Math.sqrt((x-arc.cx-arc.r*Math.cos(arc.theta2))**2+(y-arc.cy-arc.r*Math.sin(arc.theta2))**2));
				if(arc.theta1<=arc.theta2){
					if(arc.theta1<=theta&&theta<=arc.theta2){
						d=Math.min(d,Math.sqrt((x-arc.cx-arc.r*Math.cos(theta))**2+(y-arc.cy-arc.r*Math.sin(theta))**2));
					}	
				}else{
					if(theta<=arc.theta2||arc.theta1<=theta){
						d=Math.min(d,Math.sqrt((x-arc.cx-arc.r*Math.cos(theta))**2+(y-arc.cy-arc.r*Math.sin(theta))**2));
					}
				}
			}
			
			return d<=10;
		}
	}
	
	//ラベルクラス
	class Label{
		//コンストラクタ
		constructor(name,parentObject){
			this.angle=0;
			this.position=0.5;
			this.distance=20;
			this.size=10;
			this.name=name;
			this.parentObject=parentObject;
			this.color='#000000';
		}
		
		//ラベルが座標(x,y)に最も近づくように更新
		updatePosition(x,y){
			if(this.parentObject instanceof Vertex){
				this.angle=Math.atan2(y-this.parentObject.y,x-this.parentObject.x)*180/Math.PI;
			}
			if(this.parentObject instanceof Edge){
				if(this.parentObject.arc){
					let arc=this.parentObject.calcArc();
					let theta=Math.atan2(y-arc.cy,x-arc.cx);
					if(arc.theta1>arc.theta2){
						if(theta<arc.theta2){
							theta+=2*Math.PI;
						}
						arc.theta2+=2*Math.PI;
					}
					if(arc.theta1<=theta&&theta<=arc.theta2){
						this.position=(theta-arc.theta1)/(arc.theta2-arc.theta1);
					}else{
						if(theta<arc.theta1){
							if(arc.theta1-theta<theta+2*Math.PI-arc.theta2){
								this.position=0;
							}else{
								this.position=1;
							}
						}else{
							if(arc.theta1+2*Math.PI-theta<theta-arc.theta2){
								this.position=0;
							}else{
								this.position=1;
							}
						}
					}
					if(this.parentObject.radius<0){
						this.position=1-this.position;
					}
				}else{
					let line=this.parentObject.calcLine();
					this.position=-((line.x2-line.x1)*(line.x1-x)+(line.y2-line.y1)*(line.y1-y))/((line.x2-line.x1)**2+(line.y2-line.y1)**2);
					if(this.position<0){
						this.position=0;
					}
					if(this.position>1){
						this.position=1;
					}
				}
			}
		}
		
		//ラベルを表示する場所を計算
		calcPoisition(){
			if(this.parentObject instanceof Vertex){
				let x=this.parentObject.x+this.distance*Math.cos(this.angle*Math.PI/180);
				let y=this.parentObject.y+this.distance*Math.sin(this.angle*Math.PI/180);
				return {x:x,y:y};
			}
			
			if(this.parentObject instanceof Edge){
				if(this.parentObject.arc){
					let arc=this.parentObject.calcArc();
					if(arc.theta2<arc.theta1){
						arc.theta2+=2*Math.PI;
					}
					let theta;
					if(this.parentObject.radius>0){
						theta=arc.theta1+(arc.theta2-arc.theta1)*this.position;
					}else{
						theta=arc.theta1+(arc.theta2-arc.theta1)*(1-this.position);
					}
					let x=arc.cx+(arc.r+this.distance)*Math.cos(theta);
					let y=arc.cy+(arc.r+this.distance)*Math.sin(theta);
					return {x:x,y:y};
				}else{
					let line=this.parentObject.calcLine();
					let theta=Math.atan2(line.y2-line.y1,line.x2-line.x1);
					let x=line.x1+(line.x2-line.x1)*this.position-this.distance*Math.sin(theta);
					let y=line.y1+(line.y2-line.y1)*this.position+this.distance*Math.cos(theta);
					return {x:x,y:y};
				}
			}
		}
		
		draw(){
			let pos=this.calcPoisition();
			ctx.strokeStyle=this.color;
			ctx.strokeText(this.name,pos.x,pos.y);
		}
		
		//座標(x,y)と重なっているか判定
		isPointOverlapping(x,y){
			let pos=this.calcPoisition();
			return (pos.x-x)**2+(pos.y-y)**2<=this.size**2;
		}
	}
	
	let vertices=[new Vertex(100,100,0),new Vertex(200,100,1)];
	let edges=[new Edge(vertices[0],vertices[1],0)];
	let labels=[new Label('v0',vertices[0]),new Label('e0',edges[0])];
	
	//グラフを描画する関数
	function draw(){
		//canvasを初期化
		ctx.clearRect(0,0,canvas.clientWidth,canvas.height);
		
		//頂点を描画
		vertices.forEach((vertex)=>vertex.draw());
		
		//辺を描画
		edges.forEach((edge)=>edge.draw());
		
		//ラベルを描画
		labels.forEach((label)=>label.draw());
	}
	
	let clickMode="moveVertex";
	let selectedVertex=null;
	let draggedObject=null;
	let clickOffsetX,clickOffsetY;
	let focusObject;
	
	function changeClickMode(mode){
		clickMode=mode;
		switch(clickMode){
			case "moveVertex":
				selectedVertex=null;
				break;
			case "addedge":
				draggedObject=null;
				break;
			default:
				selectedVertex=null;
				draggedObject=null;
				break;
		}
	}
	
	function deleteEdge(edge){
		edge.vertex1.edges=edge.vertex1.edges.filter(function(e){
			return e!=edge;
		});
		edge.vertex2.edges=edge.vertex2.edges.filter(function(e){
			return e!=edge;
		});
		edges=edges.filter(function(e){
			return e!=edge;
		});
		for(let i=0;i<edges.length;i++){
			edges[i].id=i;
		}
	}
	
	function deleteVertex(vertex){
		focusObject.edges.forEach(function(e){
			deleteEdge(e);
		});
		vertices=vertices.filter(function(v){
			return v!=vertex;
		});
		for(let i=0;i<vertices.length;i++){
			vertices[i].id=i;
		}
	}
	
	focusObject=vertices[0];
	function coordinateXTextChanged(text){
		let coordinateXText=document.getElementById('coordinateXText');
		let x=parseFloat(text);
		if(!isNaN(x)){
			if(x<=0)x=0;
			if(x>=600)x=600;
			coordinateXText.value=x;
			focusObject.x=x;
			draw();
		}
	}
	
	function coordinateYTextChanged(text){
		let coordinateXText=document.getElementById('coordinateYText');
		let y=parseFloat(text);
		if(!isNaN(y)){
			if(y<=0)y=0;
			if(y>=600)y=600;
			coordinateYText.value=y;
			focusObject.y=y;
			draw();
		}
	}
	
	function vertexRadiusTextChanged(text){
		let vertexRadiusText=document.getElementById('vertexRadiusText');
		let r=parseFloat(text)
		if(!isNaN(r)){
			if(r<3)r=3;
			if(r>100)r=100;
			vertexRadiusText.value=r;
			focusObject.radius=r;
			draw();
		}
	}
	
	function borderColorChanged(color){
		focusObject.borderColor=color;
		draw();
	}
	
	function borderWidthTextChanged(text){
		let borderWidthText=document.getElementById('borderWidthText');
		let w=parseFloat(text);
		if(!isNaN(w)){
			if(w<1)w=1;
			if(w>10)w=10;
			borderWidthText.value=w;
			focusObject.borderWidth=w;
			draw();
		}
	}
	
	function fillCheckboxChenged(checked){
		focusObject.fill=checked;
		let fillColor=document.getElementById('fillColor');
		if(focusObject.fill){
			fillColor.style.display='block';
		}else{
			fillColor.style.display='none';
		}
		draw();
	}
	
	function vertexDeleteButtonClicked(){
		deleteVertex(focusObject);
		setFocusObject(null);
		draw();
	}
	
	function edgeColorChanged(color){
		focusObject.color=color;
		draw();
	}
	
	function edgeWidthTextChanged(text){
		let edgeWidthText=document.getElementById('edgeWidthText');
		let w=parseFloat(text);
		if(!isNaN(w)){
			if(w<1)w=1;
			if(w>10)w=10;
			edgeWidthText.value=w;
			focusObject.width=w;
			draw();
		}
	}
	
	function arcCheckboxChanged(checked){
		focusObject.arc=checked;
		let arcRadius=document.getElementById('arcRadius');
		let largeArc=document.getElementById('largeArc');
		if(checked){
			arcRadius.style.display='block';
			largeArc.style.display='block';
		}else{
			arcRadius.style.display='none';
			largeArc.style.display='none';
		}
		draw();
	}
	
	function arcRadiusTextChanged(text){
		let arcRadiusText=document.getElementById('arcRadiusText');
		let r=parseFloat(text)
		if(!isNaN(r)){
			focusObject.radius=r;
			draw();
		}
	}
	
	function largeArcCheckboxChanged(checked){
		focusObject.largeArc=checked;
		draw();
	}
	
	function startArrowCheckboxChanged(checked){
		focusObject.startArrow=checked;
		draw();
	}
	
	function endArrowCheckboxChanged(checked){
		focusObject.endArrow=checked;
		draw();
	}
	
	function arrowSizeTextChanged(text){
		let arrowSizeText=document.getElementById('arrowSizeText');
		let s=parseFloat(text)
		if(!isNaN(s)){
			if(s<1)s=1;
			focusObject.arrowSize=s;
			draw();
		}
	}
	
	function selfLoopAngleTextChanged(text){
		let selfLoopAngleText=document.getElementById('selfLoopAngleText');
		let a=parseFloat(text);
		if(!isNaN(a)){
			focusObject.selfLoopAngle=a;
			draw();
		}
	}
	
	function edgeDeleteButtonClicked(){
		deleteEdge(focusObject);
		setFocusObject(null);
		draw();
	}
	
	//フォーカスするオブジェクトを設定する
	function setFocusObject(object){
		focusObject=object;
		let vertexSettings=document.getElementById('vertex-settings');
		let edgeSettings=document.getElementById('edge-settings');
		vertexSettings.style.display='none';
		edgeSettings.style.display='none';
		//フォーカスしているオブジェクトによって表示内容を変える
		if(object instanceof Vertex){
			vertexSettings.style.display='block';
			//頂点名
			let vertexName=document.getElementById('vertexName');
			vertexName.textContent='頂点'+focusObject.id;
			
			//座標の表示
			let coordinateXText=document.getElementById('coordinateXText');
			coordinateXText.value=focusObject.x;	
			let coordinateYText=document.getElementById('coordinateYText');
			coordinateYText.value=focusObject.y;
			
			//頂点の半径の設定
			let vertexRadiusText=document.getElementById('vertexRadiusText');
			vertexRadiusText.value=focusObject.radius;
			
			//枠線の色の設定
			let borderColorPicker=document.getElementById('borderColorPicker');
			borderColorPicker.value=focusObject.borderColor;
			
			//枠線の幅の設定
			let borderWidthText=document.getElementById('borderWidthText');
			borderWidthText.value=focusObject.borderWidth;
			
			//頂点の塗りつぶし設定
			let fillCheckbox=document.getElementById('fillCheckbox');
			fillCheckbox.checked=focusObject.fill;
			
			//塗りつぶし色の設定
			let fillColor=document.getElementById('fillColor');
			if(focusObject.fill){
				fillColor.style.display='block';
			}else{
				fillColor.style.display='none';
			}
			let fillColorPicker=document.getElementById('fillColorPicker');
			fillColorPicker.value=focusObject.fillColor;
		}
		
		if(object instanceof Edge){
			edgeSettings.style.display='block';
			//辺名
			let edgeName=document.getElementById('edgeName');
			edgeName,value='辺'+focusObject.id;
			
			//辺の色の設定
			let edgeColorPicker=document.getElementById('edgeColorPicker');
			edgeColorPicker.value=focusObject.color;
			
			//辺の幅の設定
			let edgeWidthText=document.getElementById('edgeWidthText');
			edgeWidthText.value=focusObject.width;
			
			//辺を円弧状にする設定
			let arcCheckbox=document.createElement('arcCheckbox');
			arcCheckbox.checked=focusObject.arc;
			
			//弧の半径の設定
			let arcRadius=document.getElementById('arcRadius');
			if(focusObject.arc){
				arcRadius.style.display='block';
			}else{
				arcRadius.style.display='none';
			}
			let arcRadiusText=document.getElementById('arcRadiusText');		
			arcRadiusText.value=focusObject.radius;
			
			//弧を大きくする設定
			let largeArc=document.getElementById('largeArc');
			if(focusObject.arc){
				largeArc.style.display='block';
			}else{
				largeArc.style.display='none';
			}
			let largeArcCheckbox=document.getElementById('largeArcCheckbox');
			largeArcCheckbox.checked=focusObject.largeArc;
			
			//矢印の表示の有無
			let startArrorCheckbox=document.getElementById('startArrowCheckbox');
			startArrorCheckbox.value=focusObject.startArrow;
			
			let endArrorCheckbox=document.getElementById('endArrowCheckbox');
			endArrorCheckbox.value=focusObject.endArrow;
			
			//矢印の大きさの設定
			let arrowSizeText=document.getElementById('arrowSizeText');
			arrowSizeText.value=focusObject.arrowSize;
			
			//自己ループの表示角度の設定
			let selfLoopAngle=document.createElement('selfLoopAngle');
			if(!focusObject.arc||(focusObject.vertex1!=focusObject.vertex2)){
				selfLoopAngle.style.display='none';
			}else{
				selfLoopAngle.style.display='block';
			}
			let selfLoopAngleText=document.getElementById('selfLoopAngleText');
			selfLoopAngleText.value=focusObject.selfLoopAngle;
		}
	}
	
	//マウスがクリックされたときの処理
	canvas.addEventListener('mousedown',(e)=>{
		//canvas上でのマウス座標を計算
		const rect=canvas.getBoundingClientRect();
		let mouseX=e.clientX-rect.left;
		let mouseY=e.clientY-rect.top;
		
		//頂点がクリックされたかを判定
		for(let i=0;i<vertices.length;i++){
			if(vertices[i].isPointOverlapping(mouseX,mouseY)){
				if(clickMode=="moveVertex"||clickMode=="addVertex"){
					draggedObject=vertices[i];
					clickOffsetX=mouseX-vertices[i].x;
					clickOffsetY=mouseY-vertices[i].y;
				}
				if(clickMode=="addEdge"){
					selectedVertex=vertices[i];
				}
				setFocusObject(vertices[i]);
				return;
			}
		}
		
		//辺がクリックされたかを判定
		for(let i=0;i<edges.length;i++){
			if(edges[i].isPointOverlapping(mouseX,mouseY)){
				draggedObject=edges[i];
				setFocusObject(edges[i]);
				return;
			}
		}
		
		//ラベルがクリックされたかを判定
		for(let i=0;i<labels.length;i++){
			if(labels[i].isPointOverlapping(mouseX,mouseY)){
				draggedObject=labels[i];
				setFocusObject(labels[i]);
				return;
			}
		}
		
		if(clickMode=='addVertex'){
			setFocusObject(new Vertex(Math.floor(mouseX),Math.floor(mouseY),vertices.length));
			vertices.push(focusObject);
			draw();
			return;
		}
		
		setFocusObject(null);
	});
	
	//マウスが移動したときの処理
	canvas.addEventListener('mousemove',(e)=>{
		const rect=canvas.getBoundingClientRect();
		let mouseX=e.clientX-rect.left;
		let mouseY=e.clientY-rect.top;
		if(draggedObject instanceof Vertex){		
			draggedObject.x=mouseX-clickOffsetX;
			draggedObject.y=mouseY-clickOffsetY;
			if(focusObject==draggedObject){
				let coordinateX=document.getElementById('coordinateXText');
				let coordinateY=document.getElementById('coordinateYText');
				coordinateX.value=draggedObject.x;
				coordinateY.value=draggedObject.y;
			}
			draw();
		}
		if(draggedObject instanceof Edge){
			if(draggedObject.arc){
				draggedObject.updateRadius(mouseX,mouseY);
				if(focusObject==draggedObject){
					let radiusText=document.getElementById('arcRadiusText');
					let largeArc=document.getElementById('largeArcCheckbox');
					let selfLoopAngleText=document.getElementById('selfLoopAngleText');
					radiusText.value=focusObject.radius;
					largeArc.checked=focusObject.largeArc;
					selfLoopAngleText.value=focusObject.selfLoopAngle;
				}
				draw();
			}
		}
		if(draggedObject instanceof Label){
			draggedObject.updatePosition(mouseX,mouseY);
			draw();
		}
		if(selectedVertex!=null){
			draw();
			new Edge(selectedVertex,new Vertex(mouseX,mouseY,0),0).draw();
		}
	});
	
	//マウスボタンが離されたときの処理
	canvas.addEventListener('mouseup',(e)=>{
		if(selectedVertex!=null){
			//辺を追加できるなら追加する
			const rect=canvas.getBoundingClientRect();
			let mouseX=e.clientX-rect.left;
			let mouseY=e.clientY-rect.top;
			for(let i=0;i<vertices.length;i++){
				if(vertices[i].isPointOverlapping(mouseX,mouseY)){
					setFocusObject(new Edge(selectedVertex,vertices[i],edges.length));
					edges.push(focusObject);
					break;
				}
			}
		}
		draggedObject=null;
		selectedVertex=null;
		draw();
	});
	
	draw();
	
	</script>
</body>
</html>